<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é«˜å¾·åœ°å›¾æ­¥è¡Œå¯è¾¾èŒƒå›´æŸ¥è¯¢</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            overflow: hidden;
        }

        .sidebar {
            position: fixed;
            top: 0;
            left: 0;
            width: 320px;
            height: 100%;
            background: white;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            z-index: 1000;
            padding: 20px;
            overflow-y: auto;
        }

        .sidebar h2 {
            font-size: 18px;
            margin-bottom: 20px;
            color: #333;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            font-size: 14px;
            color: #666;
            margin-bottom: 8px;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            background: white;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #1890ff;
        }

        .form-group small {
            display: block;
            margin-top: 5px;
            font-size: 12px;
            color: #999;
        }

        .btn {
            width: 100%;
            padding: 12px;
            background: #1890ff;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .btn:hover {
            background: #40a9ff;
        }

        .btn:disabled {
            background: #d9d9d9;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #8c8c8c;
        }

        .btn-secondary:hover {
            background: #a8a8a8;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .btn-group .btn,
        .btn-group .btn-secondary {
            flex: 1;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .checkbox-group label {
            margin-left: 8px;
            font-size: 13px;
            color: #666;
            cursor: pointer;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .hint {
            margin-top: 10px;
            font-size: 12px;
            color: #999;
            line-height: 1.5;
        }

        .result {
            margin-top: 20px;
            padding: 10px;
            background: #f0f9ff;
            border-radius: 4px;
            font-size: 13px;
            color: #0066cc;
            display: none;
        }

        .result.show {
            display: block;
        }

        .error {
            background: #fff2f0;
            color: #ff4d4f;
        }

        #container {
            position: fixed;
            top: 0;
            left: 320px;
            right: 0;
            bottom: 0;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <h2>ğŸš¶ æ­¥è¡Œå¯è¾¾èŒƒå›´æŸ¥è¯¢</h2>

        <div class="form-group">
            <label>ä¸­å¿ƒç‚¹ç»åº¦</label>
            <input type="number" id="lng" placeholder="ä¾‹å¦‚: 106.554" step="0.000001" value="106.554">
        </div>

        <div class="form-group">
            <label>ä¸­å¿ƒç‚¹çº¬åº¦</label>
            <input type="number" id="lat" placeholder="ä¾‹å¦‚: 29.563" step="0.000001" value="29.563">
        </div>

        <div class="form-group">
            <label>æ­¥è¡Œæ—¶è€—ï¼ˆåˆ†é’Ÿï¼‰</label>
            <input type="number" id="time" placeholder="ä¾‹å¦‚: 10" min="1" max="60" value="10">
        </div>

        <div class="form-group">
            <label>ç½‘æ ¼å¤§å°ï¼ˆç±³ï¼‰</label>
            <select id="gridSize">
                <option value="200">200ç±³ï¼ˆå¿«é€Ÿï¼‰</option>
                <option value="150" selected>150ç±³ï¼ˆå¹³è¡¡ï¼‰</option>
                <option value="100">100ç±³ï¼ˆç²¾ç¡®ï¼‰</option>
                <option value="50">50ç±³ï¼ˆè¶…ç²¾ç¡®ï¼‰</option>
            </select>
            <small>ç½‘æ ¼è¶Šå°ç»“æœè¶Šç²¾ç¡®ï¼Œä½†æŸ¥è¯¢æ—¶é—´æ›´é•¿</small>
        </div>

        <div class="checkbox-group">
            <input type="checkbox" id="showDebugPoints">
            <label for="showDebugPoints">æ˜¾ç¤ºæœç´¢ç‚¹ï¼ˆé»„è‰²=æŸ¥è¯¢ç‚¹ï¼Œçº¢è‰²=è¾¹ç•Œç‚¹ï¼‰</label>
        </div>

        <div class="btn-group">
            <button class="btn" id="searchBtn" onclick="search()">ğŸ” æŸ¥è¯¢</button>
            <button class="btn btn-secondary" onclick="clearMap()">ğŸ§¹ æ¸…é™¤</button>
        </div>

        <div class="hint">
            ğŸ’¡ æç¤ºï¼šç‚¹å‡»åœ°å›¾å¯é€‰æ‹©ä¸­å¿ƒç‚¹<br>
            ğŸ“ é‡è·åŠŸèƒ½ï¼šæŒ‰ä½Shiftç‚¹å‡»åœ°å›¾å¯å¯ç”¨<br>
            ğŸ”§ éœ€è¦é«˜å¾·åœ°å›¾WebæœåŠ¡API key
        </div>

        <div class="result" id="result"></div>
    </div>

    <div id="container"></div>

    <script type="text/javascript">
        // é«˜å¾·åœ°å›¾API Key
        const AMAP_KEY = 'a4097d1dbdf4a439ff4ad1e49a18b3fb'; // Webç«¯keyï¼ˆç”¨äºæ˜¾ç¤ºåœ°å›¾ï¼‰
        const AMAP_WEB_KEY = '210c4260c793bebc10a6d3cb836430ec'; // WebæœåŠ¡keyï¼ˆç”¨äºAPIè°ƒç”¨ï¼‰

        let map = null;
        let driving = null;
        let polygon = null;
        let markers = []; // å­˜å‚¨æ‰€æœ‰æ ‡è®°
        let debugMarkers = []; // å­˜å‚¨è°ƒè¯•æ ‡è®°ç‚¹
        let ruler = null; // é‡è·å·¥å…·

        // åŠ è½½é«˜å¾·åœ°å›¾API
        function loadScript() {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.type = 'text/javascript';
                script.src = `https://webapi.amap.com/maps?v=2.0&key=${AMAP_KEY}&plugin=AMap.Driving,AMap.RulerTool`;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        // åˆå§‹åŒ–åœ°å›¾
        async function init() {
            try {
                await loadScript();

                // åˆ›å»ºåœ°å›¾å®ä¾‹
                map = new AMap.Map('container', {
                    zoom: 12,
                    center: [106.554, 29.563], // é‡åº†å¸‚
                    viewMode: '2D',
                    mapStyle: 'amap://styles/normal'
                });

                // åˆ›å»ºé‡è·å·¥å…·
                ruler = new AMap.RulerTool(map, {
                    rulerStyle: {
                        strokeColor: '#1890ff',
                        lineWidth: 2
                    },
                    showLabel: true,
                    limitMarkers: 10
                });

                // Shift+ç‚¹å‡»å¯ç”¨é‡è·å·¥å…·
                map.on('click', function(e) {
                    if (e.originalEvent && e.originalEvent.shiftKey) {
                        ruler.turnOn();
                        return;
                    }

                    document.getElementById('lng').value = e.lnglat.getLng().toFixed(6);
                    document.getElementById('lat').value = e.lnglat.getLat().toFixed(6);

                    // æ¸…é™¤æ—§æ ‡è®°
                    clearMarkers();

                    // æ·»åŠ æ–°æ ‡è®°
                    const marker = new AMap.Marker({
                        position: [e.lnglat.getLng(), e.lnglat.getLat()],
                        map: map
                    });
                    markers.push(marker);
                });

                showResult('åœ°å›¾åŠ è½½æˆåŠŸï¼<br>ğŸ’¡ æŒ‰ä½Shift+ç‚¹å‡»å¯å¼€å¯é‡è·å·¥å…·', false);
            } catch (error) {
                showResult('åœ°å›¾åŠ è½½å¤±è´¥ï¼š' + error.message, true);
            }
        }

        // æŸ¥è¯¢å¯è¾¾èŒƒå›´
        function search() {
            const lng = document.getElementById('lng').value;
            const lat = document.getElementById('lat').value;
            const time = document.getElementById('time').value;
            const gridSize = document.getElementById('gridSize').value;

            if (!lng || !lat || !time) {
                showResult('è¯·å¡«å†™å®Œæ•´ä¿¡æ¯', true);
                return;
            }

            showResult('æ­£åœ¨æŸ¥è¯¢...', false);

            // æ¸…é™¤æ—§çš„è¦†ç›–ç‰©
            if (polygon) {
                map.remove(polygon);
                polygon = null;
            }

            // æ¸…é™¤æ—§æ ‡è®°
            clearMarkers();

            // ä½¿ç”¨ç½‘æ ¼æœç´¢ç®—æ³•
            calculateAccessibleAreaWithGrid(parseFloat(lng), parseFloat(lat), parseInt(time), parseInt(gridSize));
        }

        // æ¸…é™¤åœ°å›¾ä¸Šçš„æ ‡è®°
        function clearMarkers() {
            markers.forEach(marker => {
                map.remove(marker);
            });
            markers = [];

            // æ¸…é™¤è°ƒè¯•æ ‡è®°
            debugMarkers.forEach(marker => {
                map.remove(marker);
            });
            debugMarkers = [];
        }

        // æ¸…é™¤æ‰€æœ‰å†…å®¹
        function clearMap() {
            // æ¸…é™¤å¤šè¾¹å½¢
            if (polygon) {
                map.remove(polygon);
                polygon = null;
            }

            // æ¸…é™¤æ ‡è®°
            clearMarkers();

            // æ¸…é™¤é‡è·å·¥å…·
            if (ruler) {
                ruler.turnOff();
                ruler.clear();
            }

            // æ¸…ç©ºè¾“å…¥æ¡†
            document.getElementById('lng').value = '';
                       document.getElementById('lat').value = '';

            showResult('å·²æ¸…é™¤æ‰€æœ‰æ ‡è®°å’Œè¦†ç›–ç‰©', false);
        }

        // è®¡ç®—æ­¥è¡Œæ—¶é—´ï¼ˆä½¿ç”¨é«˜å¾·WebæœåŠ¡API - é€šè¿‡JSONPæ–¹å¼è°ƒç”¨ï¼‰
        function getWalkingDuration(origin, destination) {
            return new Promise((resolve, reject) => {
                // ä½¿ç”¨JSONPæ–¹å¼è°ƒç”¨ï¼Œé¿å…CORSé—®é¢˜
                const callbackName = 'jsonp_callback_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                const url = `https://restapi.amap.com/v3/direction/walking?key=${AMAP_WEB_KEY}&origin=${origin.lng},${origin.lat}&destination=${destination.lng},${destination.lat}&output=json&callback=${callbackName}`;

                // åˆ›å»ºå…¨å±€å›è°ƒå‡½æ•°
                window[callbackName] = function(data) {
                    delete window[callbackName];
                    const script = document.getElementById(callbackName);
                    if (script) {
                        document.head.removeChild(script);
                    }

                    if (data.status === '1' && data.route && data.route.paths && data.route.paths[0]) {
                        // é«˜å¾·APIç›´æ¥è¿”å›æ€»durationï¼ˆç§’ï¼‰
                        const duration = data.route.paths[0].duration;
                        resolve(duration);
                    } else {
                        console.log('APIè¿”å›é”™è¯¯:', data);
                        reject(data.info || 'æŸ¥è¯¢å¤±è´¥');
                    }
                };

                // åˆ›å»ºscriptæ ‡ç­¾å‘é€è¯·æ±‚
                const script = document.createElement('script');
                script.id = callbackName;
                script.src = url;
                script.onerror = function() {
                    delete window[callbackName];
                    reject('ç½‘ç»œé”™è¯¯');
                };
                document.head.appendChild(script);
            });
        }

        // ç½‘æ ¼æœç´¢ç®—æ³•ï¼šæŒ‰ç½‘æ ¼æœç´¢æœ€å¤–å›´å¯è¾¾ç‚¹
        async function calculateAccessibleAreaWithGrid(lng, lat, timeMinutes, gridSize) {
            const maxTime = timeMinutes * 60; // è½¬æ¢ä¸ºç§’
            const walkingSpeed = 83.3; // æ­¥è¡Œé€Ÿåº¦ï¼ˆç±³/åˆ†é’Ÿï¼‰
            const estimatedRadius = walkingSpeed * timeMinutes; // ä¼°ç®—åŠå¾„

            // æœç´¢èŒƒå›´ï¼šä¼°ç®—åŠå¾„çš„2å€ï¼ˆæ‰©å¤§èŒƒå›´ï¼‰
            const searchRadius = estimatedRadius * 2.0;

            // æ–¹å‘åˆ†æ®µæ•°ï¼ˆç”¨äºåˆ†ç»„æ”¶é›†æœ€å¤–å›´ç‚¹ï¼‰
            const numDirections = 36; // å‡å°‘åˆ°36ä¸ªæ–¹å‘ï¼Œæ›´å®¹æ˜“æ‰¾åˆ°ç‚¹
            const anglePerDirection = (2 * Math.PI) / numDirections;

            // å­˜å‚¨æ¯ä¸ªæ–¹å‘çš„æœ€è¿œå¯è¾¾ç‚¹
            const farthestPoints = new Map();

            // æŒ‰ç½‘æ ¼é€å±‚æœç´¢ï¼ˆä»å¤–å‘å†…ï¼‰
            const gridCells = Math.ceil(searchRadius / gridSize);
            const origin = { lng, lat };
            let totalChecked = 0;
            let successCount = 0;
            let failCount = 0;

            const showDebug = document.getElementById('showDebugPoints').checked;

            console.log('å¼€å§‹æœç´¢ï¼Œæœç´¢åŠå¾„:', searchRadius, 'ç½‘æ ¼å±‚æ•°:', gridCells);

            for (let ring = gridCells; ring >= 1; ring--) {
                const currentRadius = ring * gridSize;
                const circumference = 2 * Math.PI * currentRadius;
                const numPoints = Math.max(6, Math.floor(circumference / gridSize));

                for (let i = 0; i < numPoints; i++) {
                    const angle = (i / numPoints) * 360 * (Math.PI / 180);

                    // è®¡ç®—å±äºå“ªä¸ªæ–¹å‘ï¼ˆä¿®å¤è§’åº¦è®¡ç®—ï¼‰
                    let directionIndex = Math.floor((angle % (2 * Math.PI)) / anglePerDirection);
                    if (directionIndex < 0) directionIndex += numDirections;
                    directionIndex = directionIndex % numDirections;

                    // å¦‚æœè¿™ä¸ªæ–¹å‘å·²ç»æ‰¾åˆ°äº†æœ€è¿œç‚¹ï¼Œè·³è¿‡
                    if (farthestPoints.has(directionIndex)) {
                        continue;
                    }

                    const point = {
                        lng: lng + (currentRadius / (111000 * Math.cos(lat * Math.PI / 180))) * Math.cos(angle),
                        lat: lat + (currentRadius / 111000) * Math.sin(angle),
                        distance: currentRadius,
                        angle: angle
                    };

                    try {
                        const duration = await getWalkingDuration(origin, point);
                        totalChecked++;

                        // æ˜¾ç¤ºæ‰€æœ‰æŸ¥è¯¢ç‚¹ï¼ˆé»„è‰²ï¼‰
                        if (showDebug) {
                            const debugMarker = new AMap.CircleMarker({
                                center: [point.lng, point.lat],
                                radius: 5,
                                strokeColor: '#FFD700',
                                strokeWeight: 1,
                                fillColor: '#FFD700',
                                fillOpacity: 0.8,
                                map: map
                            });
                            debugMarkers.push(debugMarker);
                        }

                        if (duration <= maxTime) {
                            // å¯è¾¾ï¼Œè®°å½•ä¸ºè¿™ä¸ªæ–¹å‘çš„æœ€è¿œç‚¹
                            farthestPoints.set(directionIndex, point);
                            successCount++;
                        }
                    } catch (error) {
                        failCount++;
                        // å¤±è´¥ä¸æ‰“å°ï¼Œé¿å…æ§åˆ¶å°åˆ·å±
                    }
                }
            }

            console.log('æœç´¢å®Œæˆï¼Œæ‰¾åˆ°å¯è¾¾ç‚¹:', successCount, 'æ€»æŸ¥è¯¢:', totalChecked, 'å¤±è´¥:', failCount);

            // å¦‚æœæ‰¾åˆ°çš„ç‚¹å¤ªå°‘ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆ
            if (farthestPoints.size < numDirections * 0.5) {
                console.log('å¯è¾¾ç‚¹å¤ªå°‘ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆ');

                // å¤‡ç”¨æ–¹æ¡ˆï¼šä½¿ç”¨ä¼°ç®—å€¼
                const fallbackPoints = [];
                for (let i = 0; i < numDirections; i++) {
                    const angle = (i / numDirections) * 360 * (Math.PI / 180);
                    const radius = estimatedRadius;
                    fallbackPoints.push({
                        lng: lng + (radius / (111000 * Math.cos(lat * Math.PI / 180))) * Math.cos(angle),
                        lat: lat + (radius / 111000) * Math.sin(angle),
                        angle: angle
                    });
                }

                const boundaryPoints = fallbackPoints;
                boundaryPoints.sort((a, b) => a.angle - b.angle);

                // æ˜¾ç¤ºè¾¹ç•Œç‚¹ï¼ˆçº¢è‰²ï¼‰
                if (showDebug) {
                    boundaryPoints.forEach(p => {
                        const debugMarker = new AMap.CircleMarker({
                            center: [p.lng, p.lat],
                            radius: 8,
                            strokeColor: '#FF0000',
                            strokeWeight: 2,
                            fillColor: '#FF0000',
                            fillOpacity: 0.8,
                            map: map
                        });
                        debugMarkers.push(debugMarker);
                    });
                }

                const polygonPath = boundaryPoints.map(p => [p.lng, p.lat]);
                polygonPath.push(polygonPath[0]);

                polygon = new AMap.Polygon({
                    path: polygonPath,
                    strokeColor: '#ff9800', // æ©™è‰²è¡¨ç¤ºå¤‡ç”¨æ–¹æ¡ˆ
                    strokeWeight: 2,
                    strokeOpacity: 0.8,
                    fillColor: '#ff9800',
                    fillOpacity: 0.2
                });

                map.add(polygon);
                map.setFitView([polygon]);

                const centerMarker = new AMap.Marker({
                    position: [lng, lat],
                    map: map
                });
                markers.push(centerMarker);

                const area = Math.PI * (estimatedRadius * estimatedRadius);
                showResult('âš ï¸ ç½‘æ ¼æŸ¥è¯¢ç»“æœä¸è¶³ï¼Œä½¿ç”¨ä¼°ç®—å€¼<br>æ­¥è¡Œ ' + timeMinutes + ' åˆ†é’Ÿçº¦ ' + estimatedRadius.toFixed(0) + ' ç±³<br>è¦†ç›–é¢ç§¯çº¦ ' + (area / 1000000).toFixed(2) + ' å¹³æ–¹å…¬é‡Œ<br>ï¼ˆæŸ¥è¯¢ ' + totalChecked + ' ä¸ªç‚¹ï¼Œ' + failCount + ' æ¬¡å¤±è´¥ï¼‰', false);
                return;
            }

            // æ”¶é›†æ‰€æœ‰æ–¹å‘çš„æœ€è¿œç‚¹å¹¶æŒ‰è§’åº¦æ’åº
            const boundaryPoints = Array.from(farthestPoints.values());
            boundaryPoints.sort((a, b) => a.angle - b.angle);

            // æ˜¾ç¤ºè¾¹ç•Œç‚¹ï¼ˆçº¢è‰²ï¼‰
            if (showDebug) {
                boundaryPoints.forEach(p => {
                    const debugMarker = new AMap.CircleMarker({
                        center: [p.lng, p.lat],
                        radius: 8,
                        strokeColor: '#FF0000',
                        strokeWeight: 2,
                        fillColor: '#FF0000',
                        fillOpacity: 0.8,
                        map: map
                    });
                    debugMarkers.push(debugMarker);
                });
            }

            // è½¬æ¢ä¸ºåæ ‡æ•°ç»„
            const polygonPath = boundaryPoints.map(p => [p.lng, p.lat]);
            polygonPath.push(polygonPath[0]); // é—­åˆ

            // åˆ›å»ºå¤šè¾¹å½¢è¦†ç›–ç‰©
            polygon = new AMap.Polygon({
                path: polygonPath,
                strokeColor: '#1890ff',
                strokeWeight: 2,
                strokeOpacity: 0.8,
                fillColor: '#1890ff',
                fillOpacity: 0.2
            });

            map.add(polygon);
            map.setFitView([polygon]);

            // æ·»åŠ ä¸­å¿ƒç‚¹æ ‡è®°
            const centerMarker = new AMap.Marker({
                position: [lng, lat],
                map: map
            });
            markers.push(centerMarker);

            const area = Math.PI * (estimatedRadius * estimatedRadius);
            showResult('âœ… æŸ¥è¯¢æˆåŠŸï¼<br>æ­¥è¡Œ ' + timeMinutes + ' åˆ†é’Ÿå¯åˆ°è¾¾çº¦ ' + estimatedRadius.toFixed(0) + ' ç±³èŒƒå›´å†…<br>è¦†ç›–é¢ç§¯çº¦ ' + (area / 1000000).toFixed(2) + ' å¹³æ–¹å…¬é‡Œ<br>æ‰¾åˆ° ' + successCount + ' ä¸ªè¾¹ç•Œç‚¹ï¼ˆæŸ¥è¯¢ ' + totalChecked + ' ä¸ªç‚¹ï¼‰<br>ç®—æ³•ï¼šç½‘æ ¼æœç´¢ï¼ˆç²¾ç¡®ï¼‰', false);
        }

        // æ˜¾ç¤ºç»“æœ
        function showResult(message, isError) {
            const resultEl = document.getElementById('result');
            resultEl.innerHTML = message;
            resultEl.className = 'result show';
            if (isError) {
                resultEl.classList.add('error');
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.onload = init;
    </script>
</body>
</html>
