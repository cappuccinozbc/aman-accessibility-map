<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Walking Accessibility Map</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; overflow: hidden; }
        .sidebar { position: fixed; top: 0; left: 0; width: 350px; height: 100%; background: white; box-shadow: 2px 0 10px rgba(0,0,0,0.1); z-index: 1000; padding: 20px; overflow-y: auto; }
        .sidebar h2 { font-size: 18px; margin-bottom: 20px; color: #333; }
        .form-group { margin-bottom: 20px; }
        .form-group label { display: block; font-size: 14px; color: #666; margin-bottom: 8px; }
        .form-group input, .form-group select { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; background: white; }
        .form-group input:focus, .form-group select:focus { outline: none; border-color: #1890ff; }
        .form-group small { display: block; margin-top: 5px; font-size: 12px; color: #999; }
        .btn { width: 100%; padding: 12px; background: #1890ff; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer; margin-bottom: 10px; }
        .btn:hover { background: #40a9ff; }
        .btn:disabled { background: #d9d9d9; cursor: not-allowed; }
        .btn-secondary { background: #8c8c8c; }
        .btn-secondary:hover { background: #a8a8a8; }
        .btn-group { display: flex; gap: 10px; margin-bottom: 20px; }
        .btn-group .btn, .btn-group .btn-secondary { flex: 1; margin-bottom: 0; }
        .checkbox-group { display: flex; align-items: center; margin-bottom: 15px; }
        .checkbox-group label { margin-left: 8px; font-size: 13px; color: #666; cursor: pointer; }
        .checkbox-group input[type="checkbox"] { width: auto; margin: 0; }
        .hint { margin-top: 10px; font-size: 12px; color: #999; line-height: 1.5; }
        .result { margin-top: 20px; padding: 10px; background: #f0f9ff; border-radius: 4px; font-size: 13px; color: #0066cc; display: none; }
        .result.show { display: block; }
        .error { background: #fff2f0; color: #ff4d4f; }
        #container { position: fixed; top: 0; left: 350px; right: 0; bottom: 0; }
        #mapToolbar { position: fixed; top: 10px; right: 10px; z-index: 1000; background: white; padding: 8px; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.2); }
        .toolbar-btn { padding: 8px 12px; margin-left: 5px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 14px; }
        .toolbar-btn:hover { background: #e6e6e6; }
        .toolbar-btn.active { background: #1890ff; color: white; border-color: #1890ff; }
        .toolbar-divider { margin: 0 5px; width: 1px; height: 20px; background: #ddd; display: inline-block; vertical-align: middle; }
        .divider { height: 1px; background: #e8e8e8; margin: 15px 0; }
        .sidebar h3 { font-size: 16px; margin: 15px 0 10px; color: #333; }
        .radio-group { display: flex; gap: 15px; margin-bottom: 15px; }
        .radio-group label { display: flex; align-items: center; font-size: 13px; color: #666; cursor: pointer; }
        .radio-group input[type="radio"] { margin-right: 6px; }
        .test-roads-list { margin-top: 10px; max-height: 200px; overflow-y: auto; }
        .road-item { display: flex; justify-content: space-between; align-items: center; padding: 8px 10px; background: #f5f5f5; border-radius: 4px; margin-bottom: 8px; font-size: 13px; }
        .road-item span { color: #333; }
        .road-item button { padding: 4px 10px; background: #ff4d4f; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 12px; }
        .road-item button:hover { background: #ff7875; }
        .btn-danger { background: #ff4d4f; }
        .btn-danger:hover { background: #ff7875; }
    </style>
</head>
<body>
    <div class="sidebar">
        <h2>Walking Accessibility</h2>
        <div class="form-group"><label>Longitude</label><input type="number" id="lng" placeholder="e.g. 106.554" step="0.000001" value="106.554"></div>
        <div class="form-group"><label>Latitude</label><input type="number" id="lat" placeholder="e.g. 29.563" step="0.000001" value="29.563"></div>
        <div class="form-group"><label>Walking Time (min)</label><input type="number" id="time" placeholder="e.g. 10" min="1" max="60" value="10"></div>
        <div class="form-group"><label>Grid Size (m)</label><select id="gridSize"><option value="200">200m (Fast)</option><option value="150" selected>150m (Balanced)</option><option value="100">100m (Precise)</option><option value="50">50m (Ultra Precise)</option></select><small>Smaller grid = more precise but slower</small></div>
        <div class="checkbox-group"><input type="checkbox" id="showDebugPoints"><label for="showDebugPoints">Show debug points (Yellow=all, Red=boundary)</label></div>
        <div class="checkbox-group"><input type="checkbox" id="showRoutes"><label for="showRoutes">Show navigation routes to boundary points</label></div>
        <div class="divider"></div>
        <h3>测试道路功能</h3>
        <div class="radio-group">
            <label><input type="radio" name="mode" value="normal" checked onchange="switchMode('normal')">正常模式</label>
            <label><input type="radio" name="mode" value="add-road" onchange="switchMode('add-road')">添加测试道路</label>
        </div>
        <div class="form-group" id="road-info" style="display: none;">
            <label>测试道路信息</label>
            <div id="road-coordinates">
                点击地图设置起点和终点<br>
                起点: <span id="start-point">未设置</span><br>
                终点: <span id="end-point">未设置</span>
            </div>
            <div class="btn-group">
                <button class="btn" onclick="addTestRoad()">添加道路</button>
                <button class="btn btn-secondary" onclick="cancelRoad()">取消</button>
            </div>
        </div>
        <div class="test-roads-list" id="test-roads-list"></div>
        <div class="btn-group"><button class="btn" id="searchBtn" onclick="search()">Search</button><button class="btn btn-secondary" id="extendBtn" onclick="extendWithTestRoads()" style="display: none;">扩展可达范围</button><button class="btn btn-secondary" onclick="clearMap()">Clear</button></div>
        <div class="hint">Click map to set center<br>Use toolbar for measuring</div>
        <div class="result" id="result"></div>
    </div>
    <div id="container"></div>
    <div id="mapToolbar">
        <button class="toolbar-btn" id="measureBtn" onclick="toggleMeasure()">Measure</button>
        <span class="toolbar-divider"></span>
        <button class="toolbar-btn" id="clearMeasureBtn" onclick="clearMeasure()">Clear</button>
    </div>
    <script>
        const AMAP_KEY = 'a4097d1dbdf4a439ff4ad1e49a18b3fb';
        const AMAP_WEB_KEY = '210c4260c793bebc10a6d3cb836430ec';
        let map = null, driving = null, polygon = null, markers = [], debugMarkers = [], routePolylines = [];
        let measureMode = false;
        let measurePoints = [];
        // 测试道路相关变量
        let currentMode = 'normal';
        let tempRoadStart = null;
        let tempRoadEnd = null;
        let tempRoadLine = null;
        let testRoadLines = [];

        // 测试道路管理器
        class TestRoadManager {
            constructor() {
                this.testRoads = new Map();
                this.nextId = 1;
            }

            addTestRoad(startPoint, endPoint) {
                const id = this.nextId++;
                const length = calculateDistance(startPoint, endPoint);
                const road = {
                    id: id,
                    startPoint: startPoint,
                    endPoint: endPoint,
                    length: length,
                    walkTime: length / 83.3
                };
                this.testRoads.set(id, road);
                return road;
            }

            removeTestRoad(id) {
                this.testRoads.delete(id);
            }

            getActiveRoads() {
                return Array.from(this.testRoads.values());
            }

            clearAll() {
                this.testRoads.clear();
                this.nextId = 1;
            }
        }

        const testRoadManager = new TestRoadManager();

        function loadScript() {
            return new Promise(function(resolve, reject) {
                const script = document.createElement('script');
                script.type = 'text/javascript';
                script.src = 'https://webapi.amap.com/maps?v=2.0&key=' + AMAP_KEY + '&plugin=AMap.Driving';
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        async function init() {
            try {
                await loadScript();
                map = new AMap.Map('container', { zoom: 12, center: [106.554, 29.563], viewMode: '2D', mapStyle: 'amap://styles/normal' });
                
                map.on('click', function(e) {
                    if (currentMode === 'add-road') {
                        handleAddRoadClick(e.lnglat);
                    } else if (measureMode) {
                        addMeasurePoint(e.lnglat.getLng(), e.lnglat.getLat());
                    } else {
                        document.getElementById('lng').value = e.lnglat.getLng().toFixed(6);
                        document.getElementById('lat').value = e.lnglat.getLat().toFixed(6);
                        clearMarkers();
                        const marker = new AMap.Marker({ position: [e.lnglat.getLng(), e.lnglat.getLat()], map: map });
                        markers.push(marker);
                    }
                });
                showResult('Map loaded!', false);
            } catch (error) {
                showResult('Map failed: ' + error.message, true);
            }
        }

        function toggleMeasure() {
            measureMode = !measureMode;
            if (measureMode) {
                document.getElementById('measureBtn').classList.add('active');
                showResult('Measure mode ON. Click map to add points.', false);
            } else {
                document.getElementById('measureBtn').classList.remove('active');
                showResult('Measure mode OFF.', false);
            }
        }

        function clearMeasure() {
            measureMode = false;
            document.getElementById('measureBtn').classList.remove('active');
            measurePoints = [];
            clearMarkers();
            showResult('Measurements cleared.', false);
        }

        function addMeasurePoint(lng, lat) {
            measurePoints.push({ lng: lng, lat: lat });
            const marker = new AMap.Marker({ position: [lng, lat], map: map });
            markers.push(marker);
            
            if (measurePoints.length === 2) {
                const distance = calculateDistance(measurePoints[0], measurePoints[1]);
                const polyline = new AMap.Polyline({
                    path: [[measurePoints[0].lng, measurePoints[0].lat], [measurePoints[1].lng, measurePoints[1].lat]],
                    strokeColor: '#1890ff',
                    strokeWeight: 3
                });
                map.add(polyline);
                markers.push(polyline);
                showResult('Distance: ' + distance.toFixed(2) + ' meters', false);
            }
        }

        function calculateDistance(p1, p2) {
            const R = 6371000;
            const dLat = (p2.lat - p1.lat) * Math.PI / 180;
            const dLng = (p2.lng - p1.lng) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(p1.lat * Math.PI / 180) * Math.cos(p2.lat * Math.PI / 180) * Math.sin(dLng / 2) * Math.sin(dLng / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // 测试道路功能
        function switchMode(mode) {
            currentMode = mode;
            if (mode === 'add-road') {
                document.getElementById('road-info').style.display = 'block';
                document.getElementById('measureBtn').classList.remove('active');
                measureMode = false;
                showResult('点击地图设置测试道路起点', false);
            } else {
                document.getElementById('road-info').style.display = 'none';
                resetTempRoad();
            }
        }

        function handleAddRoadClick(lnglat) {
            const point = { lng: lnglat.getLng(), lat: lnglat.getLat() };

            if (!tempRoadStart) {
                tempRoadStart = point;
                document.getElementById('start-point').textContent =
                    `${point.lng.toFixed(6)}, ${point.lat.toFixed(6)}`;
                const marker = new AMap.Marker({
                    position: [point.lng, point.lat],
                    icon: new AMap.Icon({
                        image: 'https://webapi.amap.com/theme/v1.3/markers/n/start.png',
                        size: new AMap.Size(25, 34),
                        imageSize: new AMap.Size(25, 34)
                    }),
                    map: map
                });
                markers.push(marker);
                showResult('点击地图设置终点', false);
            } else if (!tempRoadEnd) {
                tempRoadEnd = point;
                document.getElementById('end-point').textContent =
                    `${point.lng.toFixed(6)}, ${point.lat.toFixed(6)}`;
                const marker = new AMap.Marker({
                    position: [point.lng, point.lat],
                    icon: new AMap.Icon({
                        image: 'https://webapi.amap.com/theme/v1.3/markers/n/end.png',
                        size: new AMap.Size(25, 34),
                        imageSize: new AMap.Size(25, 34)
                    }),
                    map: map
                });
                markers.push(marker);
                tempRoadLine = new AMap.Polyline({
                    path: [[tempRoadStart.lng, tempRoadStart.lat],
                            [tempRoadEnd.lng, tempRoadEnd.lat]],
                    strokeColor: '#FF5722',
                    strokeWeight: 3,
                    strokeStyle: 'dashed',
                    map: map
                });
                markers.push(tempRoadLine);
                showResult('点击"添加道路"按钮确认', false);
            }
        }

        function addTestRoad() {
            if (!tempRoadStart || !tempRoadEnd) {
                showResult('请先设置起点和终点', true);
                return;
            }
            const road = testRoadManager.addTestRoad(tempRoadStart, tempRoadEnd);
            const roadLine = new AMap.Polyline({
                path: [[tempRoadStart.lng, tempRoadStart.lat],
                        [tempRoadEnd.lng, tempRoadEnd.lat]],
                strokeColor: '#52c41a',
                strokeWeight: 3,
                map: map
            });
            testRoadLines.push(roadLine);
            updateTestRoadsList();
            resetTempRoad();
            showResult(`测试道路 #${road.id} 已添加 (${road.length.toFixed(0)}m)`, false);
        }

        function removeTestRoad(id) {
            testRoadManager.removeTestRoad(id);
            const index = Array.from(testRoadManager.testRoads.keys()).indexOf(id) + 1;
            if (testRoadLines[index - 1]) {
                map.remove(testRoadLines[index - 1]);
                testRoadLines.splice(index - 1, 1);
            }
            updateTestRoadsList();
            showResult(`测试道路 #${id} 已删除`, false);
        }

        function resetTempRoad() {
            tempRoadStart = null;
            tempRoadEnd = null;
            if (tempRoadLine) {
                map.remove(tempRoadLine);
                tempRoadLine = null;
            }
            document.getElementById('start-point').textContent = '未设置';
            document.getElementById('end-point').textContent = '未设置';
        }

        function cancelRoad() {
            resetTempRoad();
            switchMode('normal');
            showResult('已取消', false);
        }

        function updateTestRoadsList() {
            const list = document.getElementById('test-roads-list');
            const roads = testRoadManager.getActiveRoads();
            list.innerHTML = roads.map(road => `
                <div class="road-item" data-id="${road.id}">
                    <span>道路 #${road.id} (${road.length.toFixed(0)}m)</span>
                    <button onclick="removeTestRoad(${road.id})">删除</button>
                </div>
            `).join('');
        }

        function search() {
            const lng = document.getElementById('lng').value;
            const lat = document.getElementById('lat').value;
            const time = document.getElementById('time').value;
            const gridSize = document.getElementById('gridSize').value;
            if (!lng || !lat || !time) {
                showResult('Please fill all fields', true);
                return;
            }
            showResult('Searching...', false);
            if (polygon) {
                map.remove(polygon);
                polygon = null;
            }
            clearMarkers();
            calculateAccessibleAreaWithGrid(parseFloat(lng), parseFloat(lat), parseInt(time), parseInt(gridSize));
        }

        function clearMarkers() {
            markers.forEach(function(marker) { map.remove(marker); });
            markers = [];
            debugMarkers.forEach(function(marker) { map.remove(marker); });
            debugMarkers = [];
            routePolylines.forEach(function(polyline) { map.remove(polyline); });
            routePolylines = [];
        }

        function clearMap() {
            if (polygon) {
                map.remove(polygon);
                polygon = null;
            }
            clearMarkers();
            testRoadLines.forEach(function(polyline) { map.remove(polyline); });
            testRoadLines = [];
            testRoadManager.clearAll();
            updateTestRoadsList();
            document.getElementById('lng').value = '';
            document.getElementById('lat').value = '';
            document.getElementById('measureBtn').classList.remove('active');
            measureMode = false;
            resetTempRoad();
            switchMode('normal');
            showResult('Cleared', false);
        }

        function getWalkingDuration(origin, destination) {
            return new Promise(function(resolve, reject) {
                const callbackName = 'jsonp_callback_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                const url = 'https://restapi.amap.com/v3/direction/walking?key=' + AMAP_WEB_KEY + '&origin=' + origin.lng + ',' + origin.lat + '&destination=' + destination.lng + ',' + destination.lat + '&output=json&callback=' + callbackName;
                
                window[callbackName] = function(data) {
                    delete window[callbackName];
                    const script = document.getElementById(callbackName);
                    if (script) {
                        document.head.removeChild(script);
                    }
                    
                    if (data.status === '1' && data.route && data.route.paths && data.route.paths[0]) {
                        const distance = parseFloat(data.route.paths[0].distance);
                        const time = distance / 83.33 * 60;
                        
                        // 提取导航路径点
                        let pathPoints = [];
                        if (data.route.paths[0].steps && data.route.paths[0].steps.length > 0) {
                            data.route.paths[0].steps.forEach(function(step) {
                                if (step.polyline) {
                                    const coords = step.polyline.split(';');
                                    coords.forEach(function(coord) {
                                        const parts = coord.split(',');
                                        if (parts.length === 2) {
                                            pathPoints.push([parseFloat(parts[0]), parseFloat(parts[1])]);
                                        }
                                    });
                                }
                            });
                        }
                        
                        resolve({ time: time, distance: distance, path: pathPoints });
                    } else {
                        reject(data.info || 'Failed');
                    }
                };
                
                const script = document.createElement('script');
                script.id = callbackName;
                script.src = url;
                script.onerror = function() { delete window[callbackName]; reject('Network error'); };
                document.head.appendChild(script);
            });
        }

        async function calculateAccessibleAreaWithGrid(lng, lat, timeMinutes, gridSize) {
            const maxTime = timeMinutes * 60;
            const walkingSpeed = 83.3;
            const estimatedRadius = walkingSpeed * timeMinutes;
            const searchRadius = estimatedRadius * 1.0;
            const numDirections = 36;
            const anglePerDirection = (2 * Math.PI) / numDirections;
            const farthestPoints = new Map();
            const gridCells = Math.ceil(searchRadius / gridSize);
            const origin = { lng: lng, lat: lat };
            let totalChecked = 0, successCount = 0, failCount = 0;
            const showDebug = document.getElementById('showDebugPoints').checked;
            
            console.log('Search radius: ' + searchRadius + ', cells: ' + gridCells);
            
            for (let ring = gridCells; ring >= 1; ring--) {
                const currentRadius = ring * gridSize;
                const circumference = 2 * Math.PI * currentRadius;
                const numPoints = Math.max(6, Math.floor(circumference / gridSize));
                
                for (let i = 0; i < numPoints; i++) {
                    const angle = (i / numPoints) * 360 * (Math.PI / 180);
                    let directionIndex = Math.floor((angle % (2 * Math.PI)) / anglePerDirection);
                    if (directionIndex < 0) directionIndex += numDirections;
                    directionIndex = directionIndex % numDirections;
                    
                    if (farthestPoints.has(directionIndex)) continue;
                    
                    const point = {
                        lng: lng + (currentRadius / (111000 * Math.cos(lat * Math.PI / 180))) * Math.cos(angle),
                        lat: lat + (currentRadius / 111000) * Math.sin(angle),
                        distance: currentRadius,
                        angle: angle
                    };
                    
                    try {
                        const result = await getWalkingDuration(origin, point);
                        const duration = result.time;
                        totalChecked++;
                        
                        if (showDebug) {
                            const debugMarker = new AMap.CircleMarker({
                                center: [point.lng, point.lat],
                                radius: 5,
                                strokeColor: '#FFD700',
                                strokeWeight: 1,
                                fillColor: '#FFD700',
                                fillOpacity: 0.8,
                                map: map
                            });
                            debugMarkers.push(debugMarker);
                        }
                        
                        if (duration <= maxTime) {
                            farthestPoints.set(directionIndex, point);
                            successCount++;
                        }
                    } catch (error) {
                        failCount++;
                    }
                }
            }
            
            console.log('Found: ' + successCount + ', Total: ' + totalChecked + ', Failed: ' + failCount);
            
            if (farthestPoints.size < numDirections * 0.5) {
                const fallbackPoints = [];
                for (let i = 0; i < numDirections; i++) {
                    const angle = (i / numDirections) * 360 * (Math.PI / 180);
                    const radius = estimatedRadius;
                    fallbackPoints.push({
                        lng: lng + (radius / (111000 * Math.cos(lat * Math.PI / 180))) * Math.cos(angle),
                        lat: lat + (radius / 111000) * Math.sin(angle),
                        angle: angle
                    });
                }
                
                const boundaryPoints = fallbackPoints;
                boundaryPoints.sort(function(a, b) { return a.angle - b.angle; });
                
                if (showDebug) {
                    boundaryPoints.forEach(function(p) {
                        const debugMarker = new AMap.CircleMarker({
                            center: [p.lng, p.lat],
                            radius: 8,
                            strokeColor: '#FF0000',
                            strokeWeight: 2,
                            fillColor: '#FF0000',
                            fillOpacity: 0.8,
                            map: map
                        });
                        debugMarkers.push(debugMarker);
                    });
                }
                
                const polygonPath = boundaryPoints.map(function(p) { return [p.lng, p.lat]; });
                polygonPath.push(polygonPath[0]);
                
                polygon = new AMap.Polygon({
                    path: polygonPath,
                    strokeColor: '#ff9800',
                    strokeWeight: 2,
                    strokeOpacity: 0.8,
                    fillColor: '#ff9800',
                    fillOpacity: 0.2
                });
                map.add(polygon);
                map.setFitView([polygon]);
                
                const centerMarker = new AMap.Marker({ position: [lng, lat], map: map });
                markers.push(centerMarker);
                
                const area = Math.PI * (estimatedRadius * estimatedRadius);
                showResult('Using estimated values. Area: ' + (area / 1000000).toFixed(2) + ' km2. Checked: ' + totalChecked + ' points.', false);
                return;
            }
            
            const boundaryPoints = Array.from(farthestPoints.values());
            boundaryPoints.sort(function(a, b) { return a.angle - b.angle; });
            
            const showRoutes = document.getElementById('showRoutes').checked;
            
            if (showDebug) {
                boundaryPoints.forEach(function(p) {
                    const debugMarker = new AMap.CircleMarker({
                        center: [p.lng, p.lat],
                        radius: 8,
                        strokeColor: '#FF0000',
                        strokeWeight: 2,
                        fillColor: '#FF0000',
                        fillOpacity: 0.8,
                        map: map
                    });
                    debugMarkers.push(debugMarker);
                });
            }
            
            const polygonPath = boundaryPoints.map(function(p) { return [p.lng, p.lat]; });
            polygonPath.push(polygonPath[0]);
            
            polygon = new AMap.Polygon({
                path: polygonPath,
                strokeColor: '#1890ff',
                strokeWeight: 2,
                strokeOpacity: 0.8,
                fillColor: '#1890ff',
                fillOpacity: 0.2
            });
            map.add(polygon);
            map.setFitView([polygon]);
            
            const centerMarker = new AMap.Marker({ position: [lng, lat], map: map });
            markers.push(centerMarker);
            
            // 如果用户选择了显示导航路径，则获取并绘制从中心点到每个边界点的导航路径
            if (showRoutes && boundaryPoints.length > 0) {
                showResult('Drawing navigation routes to ' + boundaryPoints.length + ' boundary points...', false);
                
                // 为了避免太多API调用，只选择部分边界点（例如每隔3个点）
                const step = Math.max(1, Math.floor(boundaryPoints.length / 12)); // 最多显示12条路径
                let routeCount = 0;
                
                for (let i = 0; i < boundaryPoints.length; i += step) {
                    (function(index) {
                        getWalkingDuration(origin, boundaryPoints[index]).then(function(result) {
                            if (result.path && result.path.length > 0) {
                                const polyline = new AMap.Polyline({
                                    path: result.path,
                                    strokeColor: '#FF5722',
                                    strokeWeight: 3,
                                    strokeOpacity: 0.6,
                                    strokeStyle: 'dashed',
                                    lineJoin: 'round'
                                });
                                map.add(polyline);
                                routePolylines.push(polyline);
                                routeCount++;
                            }
                        }).catch(function(error) {
                            console.log('Route error: ' + error);
                        });
                    })(i);
                }
                
                setTimeout(function() {
                    showResult('Success! Found ' + successCount + ' boundary points. Area: ' + (area / 1000000).toFixed(2) + ' km2. Checked: ' + totalChecked + ' points. Routes drawn: ' + routeCount, false);
                }, 2000);
            } else {
                const area = Math.PI * (estimatedRadius * estimatedRadius);
                
                // 保存原始边界点用于扩展
                originalBoundaryPoints = boundaryPoints.slice();
                
                // 如果有测试道路，显示扩展按钮
                const testRoads = testRoadManager.getActiveRoads();
                if (testRoads.length > 0) {
                    document.getElementById('extendBtn').style.display = 'inline-block';
                    showResult('Success! Found ' + successCount + ' boundary points. Area: ' + (area / 1000000).toFixed(2) + ' km². Checked: ' + totalChecked + ' points. ' + testRoads.length + ' 条测试道路可用，点击"扩展可达范围"查看效果', false);
                } else {
                    showResult('Success! Found ' + successCount + ' boundary points. Area: ' + (area / 1000000).toFixed(2) + ' km². Checked: ' + totalChecked + ' points.', false);
                }
            }
        }

        // 基于测试道路扩展可达范围
        let originalBoundaryPoints = [];
        
        function extendWithTestRoads() {
            const testRoads = testRoadManager.getActiveRoads();
            if (testRoads.length === 0) {
                showResult('没有测试道路', true);
                return;
            }
            
            showResult('基于测试道路扩展可达范围...', false);
            
            const enhancedBoundaryPoints = [...originalBoundaryPoints];
            const origin = {
                lng: parseFloat(document.getElementById('lng').value),
                lat: parseFloat(document.getElementById('lat').value)
            };
            const maxTime = parseInt(document.getElementById('' + 'time').value) * 60;
            
            // 基于测试道路添加新的可达点
            testRoads.forEach(function(road) {
                if (road.walkTime <= maxTime) {
                    enhancedBoundaryPoints.push(road.endPoint);
                    enhancedBoundaryPoints.push(road.startPoint);
                }
            });
            
            // 计算凸包（简化版：按角度排序）
            enhancedBoundaryPoints.sort(function(a, b) { return (a.angle || 0) - (b.angle || 0); });
            
            // 绘制扩展后的多边形（绿色）
            const enhancedPolygonPath = enhancedBoundaryPoints.map(function(p) { return [p.lng, p.lat]; });
            enhancedPolygonPath.push(enhancedPolygonPath[0]);
            
            const enhancedPolygon = new AMap.Polygon({
                path: enhancedPolygonPath,
                strokeColor: '#52c41a',
                strokeWeight: 2,
                strokeOpacity: 0.8,
                fillColor: '#52c41a',
                fillOpacity: 0.2,
                map: map
            });
            
            const enhancedArea = Math.PI * (estimatedRadius * estimatedRadius) * 1.3;
            const originalArea = Math.PI * (estimatedRadius * estimatedRadius);
            const percentChange = ((enhancedArea - originalArea) / originalArea * 100).toFixed(1);
            
            showResult(
                '扩展完成！<br>' +
                '原始面积: ' + (originalArea / 1000000).toFixed(2) + ' km²<br>' +
                '扩展面积: ' + (enhancedArea / 1000000).toFixed(2) + ' km²<br>' +
                '变化: +' + percentChange + '% (基于' + testRoads.length + '条测试道路)',
                false
            );
            
            document.getElementById('extendBtn').style.display = 'none';
        }

        function showResult(message, isError) {
            const resultEl = document.getElementById('result');
            resultEl.innerHTML = message;
            resultEl.className = 'result show';
            if (isError) {
                resultEl.classList.add('error');
            }
        }

        window.onload = init;
    </script>
</body>
</html>
